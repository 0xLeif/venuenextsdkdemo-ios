// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name VNNetworkService
import Foundation
import Network
import Swift
import SystemConfiguration
@_exported import VNNetworkService
import os.log
import os
public struct AnyError : Swift.Error {
  public let error: Swift.Error
  public init(_ error: Swift.Error)
}
extension AnyError : VNNetworkService.ErrorConvertible {
  public static func error(from error: Swift.Error) -> VNNetworkService.AnyError
}
extension AnyError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
}
public protocol VNDecodableContainer : Swift.Decodable {
  associatedtype ContainedType : Swift.Decodable
  var element: Self.ContainedType { get }
}
extension VNRequest where T : Swift.Decodable {
  public init<U>(method: VNNetworkService.HTTP.Method, url: Foundation.URL, headers: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]? = nil, body: Foundation.Data? = nil, cachePolicy: Foundation.URLRequest.CachePolicy = RequestDefaults.defaultCachePolicy, timeout: Foundation.TimeInterval = RequestDefaults.defaultTimeout, decoder: Foundation.JSONDecoder = JSONDecoder(), containerType: U.Type) where T == U.ContainedType, U : VNNetworkService.VNDecodableContainer
}
extension VNAnyError : VNNetworkService.VNDecodingFailureInitializable {
  public init(error: Swift.DecodingError, decoding: Swift.Decodable.Type, data: Foundation.Data)
}
public protocol VNNetworkServiceFailureInitializable : Swift.Error {
  var failureResponse: VNNetworkService.HTTP.Response? { get }
  var httpServiceError: VNNetworkService.VNNetworkError { get }
  init(networkServiceFailure: VNNetworkService.VNNetworkServiceFailure)
}
public protocol VNDecodingFailureInitializable : Swift.Error {
  init(error: Swift.DecodingError, decoding: Swift.Decodable.Type, data: Foundation.Data)
}
public typealias RequestTransformBlock<T, E> = (VNNetworkService.VNNetworkServiceSuccess) -> Swift.Result<T, E> where E : Swift.Error
public protocol Request {
  associatedtype ResponseType
  associatedtype ErrorType : VNNetworkService.VNNetworkServiceFailureInitializable
  var method: VNNetworkService.HTTP.Method { get }
  var url: Foundation.URL { get }
  var urlRequest: Foundation.URLRequest { get }
  var headers: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]? { get set }
  var body: Foundation.Data? { get set }
  var cachePolicy: Foundation.URLRequest.CachePolicy { get }
  var timeout: Foundation.TimeInterval { get }
  func transformSuccess(_ networkServiceSuccess: VNNetworkService.VNNetworkServiceSuccess) -> Swift.Result<Self.ResponseType, Self.ErrorType>
}
public struct EmptyResponse {
  public init()
}
public struct RequestDefaults {
  public static var defaultCachePolicy: Foundation.URLRequest.CachePolicy
  public static var defaultTimeout: Foundation.TimeInterval
  public typealias DecodingErrorTransformer<E> = (Swift.Error, Any.Type, Foundation.Data) -> E
  public static func successTransformer<ResponseType, ErrorType>(for decoder: Foundation.JSONDecoder) -> VNNetworkService.RequestTransformBlock<ResponseType, ErrorType> where ResponseType : Swift.Decodable, ErrorType : VNNetworkService.VNDecodingFailureInitializable
  public static func successTransformer<ResponseType, ErrorType>(for decoder: Foundation.JSONDecoder, catchTransformer: @escaping VNNetworkService.RequestDefaults.DecodingErrorTransformer<ErrorType>) -> VNNetworkService.RequestTransformBlock<ResponseType, ErrorType> where ResponseType : Swift.Decodable, ErrorType : Swift.Error
  public static func successTransformer<ContainerType, ErrorType>(for decoder: Foundation.JSONDecoder, withContainerType containerType: ContainerType.Type) -> VNNetworkService.RequestTransformBlock<ContainerType.ContainedType, ErrorType> where ContainerType : VNNetworkService.VNDecodableContainer, ErrorType : VNNetworkService.VNDecodingFailureInitializable
  public static func successTransformer<ContainerType, ErrorType>(for decoder: Foundation.JSONDecoder, withContainerType containerType: ContainerType.Type, catchTransformer: @escaping VNNetworkService.RequestDefaults.DecodingErrorTransformer<ErrorType>) -> VNNetworkService.RequestTransformBlock<ContainerType.ContainedType, ErrorType> where ContainerType : VNNetworkService.VNDecodableContainer, ErrorType : Swift.Error
}
extension Request {
  public var urlRequest: Foundation.URLRequest {
    get
  }
  public var cachePolicy: Foundation.URLRequest.CachePolicy {
    get
  }
  public var timeout: Foundation.TimeInterval {
    get
  }
  public func addingHeaders(_ additionalHeaders: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]) -> Self
  public func usingHeaders(_ headers: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]?) -> Self
  public func usingBody(_ body: Foundation.Data?) -> Self
}
extension Request where Self.ErrorType : VNNetworkService.VNDecodingFailureInitializable, Self.ResponseType : Swift.Decodable {
  public func dataTransformer(with decoder: Foundation.JSONDecoder) -> VNNetworkService.RequestTransformBlock<Self.ResponseType, Self.ErrorType>
  public func transformSuccess(_ networkServiceSuccess: VNNetworkService.VNNetworkServiceSuccess) -> Swift.Result<Self.ResponseType, Self.ErrorType>
}
extension Request where Self.ResponseType == VNNetworkService.EmptyResponse {
  public func transformSuccess(_ networkServiceSuccess: VNNetworkService.VNNetworkServiceSuccess) -> Swift.Result<VNNetworkService.EmptyResponse, Self.ErrorType>
}
extension Result {
  public typealias Value = Success
  public typealias Error = Failure
}
extension Result {
  public typealias Success = Swift.Result<Success, Failure>.Value
  public typealias Failure = Swift.Result<Success, Failure>.Error
}
extension Result {
  public init(_ value: Swift.Result<Success, Failure>.Value?, failWith: @autoclosure () -> Swift.Result<Success, Failure>.Error)
  public init(_ f: @autoclosure () throws -> Swift.Result<Success, Failure>.Value)
  @available(*, deprecated, renamed: "init(catching:)")
  public init(attempt f: () throws -> Swift.Result<Success, Failure>.Value)
  public init(catching body: () throws -> Success)
  @available(*, deprecated, renamed: "get()")
  public func dematerialize() throws -> Swift.Result<Success, Failure>.Value
  public func get() throws -> Success
  public func analysis<Result>(ifSuccess: (Swift.Result<Success, Failure>.Value) -> Result, ifFailure: (Swift.Result<Success, Failure>.Error) -> Result) -> Result
  public static var errorDomain: Swift.String {
    get
  }
  public static var functionKey: Swift.String {
    get
  }
  public static var fileKey: Swift.String {
    get
  }
  public static var lineKey: Swift.String {
    get
  }
  public static func error(_ message: Swift.String? = nil, function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line) -> Foundation.NSError
}
extension Result : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Result : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Result : VNNetworkService.ResultProtocol {
  public init(value: Swift.Result<Success, Failure>.Value)
  public init(error: Swift.Result<Success, Failure>.Error)
  public var result: Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error> {
    get
  }
}
extension Result where Failure == VNNetworkService.AnyError {
  public init(_ f: @autoclosure () throws -> Swift.Result<Success, Failure>.Value)
  public init(attempt f: () throws -> Swift.Result<Success, Failure>.Value)
}
@available(*, deprecated, renamed: "Result.init(attempt:)")
public func materialize<T>(_ f: () throws -> T) -> Swift.Result<T, VNNetworkService.AnyError>
@available(*, deprecated, renamed: "Result.init(_:)")
public func materialize<T>(_ f: @autoclosure () throws -> T) -> Swift.Result<T, VNNetworkService.AnyError>
extension NSError : VNNetworkService.ErrorConvertible {
  public static func error(from error: Swift.Error) -> Self
}
@available(*, unavailable, message: "Use the overload which returns `Result<T, AnyError>` instead")
public func materialize<T>(_ f: () throws -> T) -> Swift.Result<T, Foundation.NSError>
@available(*, unavailable, message: "Use the overload which returns `Result<T, AnyError>` instead")
public func materialize<T>(_ f: @autoclosure () throws -> T) -> Swift.Result<T, Foundation.NSError>
@available(*, unavailable, message: "This has been removed. Use `Result.init(attempt:)` instead. See https://github.com/antitypical/Result/issues/85 for the details.")
public func `try`<T>(_ function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line, try: (Foundation.NSErrorPointer) -> T?) -> Swift.Result<T, Foundation.NSError>
@available(*, unavailable, message: "This has been removed. Use `Result.init(attempt:)` instead. See https://github.com/antitypical/Result/issues/85 for the details.")
public func `try`(_ function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line, try: (Foundation.NSErrorPointer) -> Swift.Bool) -> Swift.Result<(), Foundation.NSError>
@objc final public class NetworkMonitor : ObjectiveC.NSObject {
  @objc public static var shared: VNNetworkService.NetworkMonitor
  @objc final public var isMonitoring: Swift.Bool
  public static var networkReachableNotificationName: Foundation.Notification.Name {
    get
  }
  public static var networkUnreachableNotificationName: Foundation.Notification.Name {
    get
  }
  public static var networkStatusChangedNotificationName: Foundation.Notification.Name {
    get
  }
  final public var isNetworkAccessible: Swift.Bool {
    get
    }
  final public func start()
  final public func stop()
  @objc override dynamic public init()
  @objc deinit
}
public struct HTTP {
  public enum Method : Swift.String {
    case get
    case head
    case post
    case put
    case delete
    case patch
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
  }
  public struct HeaderKey : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
  public struct HeaderValue : Swift.RawRepresentable, Swift.Equatable {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
  public enum Status {
    public struct Success : Swift.RawRepresentable, Swift.Equatable {
      public var rawValue: Swift.Int
      public init(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
    }
    public struct Redirection : Swift.RawRepresentable, Swift.Equatable {
      public var rawValue: Swift.Int
      public init(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
    }
    public struct ClientError : Swift.RawRepresentable, Swift.Equatable {
      public var rawValue: Swift.Int
      public init(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
    }
    public struct ServerError : Swift.RawRepresentable, Swift.Equatable {
      public var rawValue: Swift.Int
      public init(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
    }
    case unknown(Swift.Int)
    case success(VNNetworkService.HTTP.Status.Success)
    case redirection(VNNetworkService.HTTP.Status.Redirection)
    case clientError(VNNetworkService.HTTP.Status.ClientError)
    case serverError(VNNetworkService.HTTP.Status.ServerError)
  }
  public struct Response : Swift.Equatable {
    public let code: Swift.Int
    public let data: Foundation.Data?
    public let headers: [Swift.String : Swift.String]?
    public var status: VNNetworkService.HTTP.Status {
      get
    }
    public var dataString: Swift.String? {
      get
    }
    public init(code: Swift.Int, data: Foundation.Data?, headers: [Swift.String : Swift.String]? = nil)
    public static func == (a: VNNetworkService.HTTP.Response, b: VNNetworkService.HTTP.Response) -> Swift.Bool
  }
}
extension HTTP.HeaderKey {
  public static let accept: VNNetworkService.HTTP.HeaderKey
  public static let acceptCharset: VNNetworkService.HTTP.HeaderKey
  public static let acceptEncoding: VNNetworkService.HTTP.HeaderKey
  public static let acceptLanguage: VNNetworkService.HTTP.HeaderKey
  public static let acceptDatetime: VNNetworkService.HTTP.HeaderKey
  public static let authorization: VNNetworkService.HTTP.HeaderKey
  public static let contentLength: VNNetworkService.HTTP.HeaderKey
  public static let contentMD5: VNNetworkService.HTTP.HeaderKey
  public static let contentType: VNNetworkService.HTTP.HeaderKey
  public static let date: VNNetworkService.HTTP.HeaderKey
  public static let userAgent: VNNetworkService.HTTP.HeaderKey
  public static let cacheControl: VNNetworkService.HTTP.HeaderKey
}
extension HTTP.HeaderValue {
  public static let applicationJSON: VNNetworkService.HTTP.HeaderValue
  public static let applicationFormURLEncoded: VNNetworkService.HTTP.HeaderValue
  public static let applicationXML: VNNetworkService.HTTP.HeaderValue
  public static let multipartForm: VNNetworkService.HTTP.HeaderValue
  public static let textPlain: VNNetworkService.HTTP.HeaderValue
  public static let imagePNG: VNNetworkService.HTTP.HeaderValue
  public static let imageJPEG: VNNetworkService.HTTP.HeaderValue
  public static let imageGIF: VNNetworkService.HTTP.HeaderValue
  public static let encodingCompress: VNNetworkService.HTTP.HeaderValue
  public static let encodingDeflate: VNNetworkService.HTTP.HeaderValue
  public static let encodingExi: VNNetworkService.HTTP.HeaderValue
  public static let encodingGzip: VNNetworkService.HTTP.HeaderValue
  public static let encodingIdentity: VNNetworkService.HTTP.HeaderValue
  public static let encodingPack200Gzip: VNNetworkService.HTTP.HeaderValue
  public static let encodingBr: VNNetworkService.HTTP.HeaderValue
  public static let passKit: VNNetworkService.HTTP.HeaderValue
  public static let jsonAPI: VNNetworkService.HTTP.HeaderValue
  public static let noCache: VNNetworkService.HTTP.HeaderValue
  public static let maxAgeCache: VNNetworkService.HTTP.HeaderValue
  public static func authorizationBearer(token: Swift.String) -> VNNetworkService.HTTP.HeaderValue
  public static let defaultUserAgent: VNNetworkService.HTTP.HeaderValue
}
extension HTTP.Status.Success {
  public static let ok: VNNetworkService.HTTP.Status.Success
  public static let created: VNNetworkService.HTTP.Status.Success
  public static let accepted: VNNetworkService.HTTP.Status.Success
  public static let nonAuthoritativeInformation: VNNetworkService.HTTP.Status.Success
  public static let noContent: VNNetworkService.HTTP.Status.Success
  public static let resetContent: VNNetworkService.HTTP.Status.Success
  public static let partialContent: VNNetworkService.HTTP.Status.Success
  public static let multiStatus: VNNetworkService.HTTP.Status.Success
  public static let alreadyReported: VNNetworkService.HTTP.Status.Success
  public static let imUsed: VNNetworkService.HTTP.Status.Success
}
extension HTTP.Status.Redirection {
  public static let multipleChoices: VNNetworkService.HTTP.Status.Redirection
  public static let movedPermanently: VNNetworkService.HTTP.Status.Redirection
  public static let found: VNNetworkService.HTTP.Status.Redirection
  public static let seeOther: VNNetworkService.HTTP.Status.Redirection
  public static let notModified: VNNetworkService.HTTP.Status.Redirection
  public static let useProxy: VNNetworkService.HTTP.Status.Redirection
  public static let switchProxy: VNNetworkService.HTTP.Status.Redirection
  public static let temporaryRedirect: VNNetworkService.HTTP.Status.Redirection
  public static let permanentRedirect: VNNetworkService.HTTP.Status.Redirection
}
extension HTTP.Status.ClientError {
  public static let badRequest: VNNetworkService.HTTP.Status.ClientError
  public static let unauthorized: VNNetworkService.HTTP.Status.ClientError
  public static let paymentRequired: VNNetworkService.HTTP.Status.ClientError
  public static let forbidden: VNNetworkService.HTTP.Status.ClientError
  public static let notFound: VNNetworkService.HTTP.Status.ClientError
  public static let methodNotAllowed: VNNetworkService.HTTP.Status.ClientError
  public static let notAcceptable: VNNetworkService.HTTP.Status.ClientError
  public static let proxyAuthenticationRequired: VNNetworkService.HTTP.Status.ClientError
  public static let requestTimeout: VNNetworkService.HTTP.Status.ClientError
  public static let conflict: VNNetworkService.HTTP.Status.ClientError
  public static let gone: VNNetworkService.HTTP.Status.ClientError
  public static let lengthRequried: VNNetworkService.HTTP.Status.ClientError
  public static let preconditionFailed: VNNetworkService.HTTP.Status.ClientError
  public static let payloadTooLarge: VNNetworkService.HTTP.Status.ClientError
  public static let uriTooLong: VNNetworkService.HTTP.Status.ClientError
  public static let unsupportedMediaType: VNNetworkService.HTTP.Status.ClientError
  public static let rangeNotSatisfiable: VNNetworkService.HTTP.Status.ClientError
  public static let expectationFailed: VNNetworkService.HTTP.Status.ClientError
  public static let imATeapot: VNNetworkService.HTTP.Status.ClientError
  public static let misdirectedRequest: VNNetworkService.HTTP.Status.ClientError
  public static let unproccessableEntity: VNNetworkService.HTTP.Status.ClientError
  public static let locked: VNNetworkService.HTTP.Status.ClientError
  public static let failedDependency: VNNetworkService.HTTP.Status.ClientError
  public static let upgradeRequired: VNNetworkService.HTTP.Status.ClientError
  public static let preconditionRequired: VNNetworkService.HTTP.Status.ClientError
  public static let tooManyRequests: VNNetworkService.HTTP.Status.ClientError
  public static let requestHeaderFieldsTooLarge: VNNetworkService.HTTP.Status.ClientError
  public static let unavailableForLegalReasons: VNNetworkService.HTTP.Status.ClientError
}
extension HTTP.Status.ServerError {
  public static let internalServerError: VNNetworkService.HTTP.Status.ServerError
  public static let notImplemented: VNNetworkService.HTTP.Status.ServerError
  public static let badGateway: VNNetworkService.HTTP.Status.ServerError
  public static let serviceUnavailable: VNNetworkService.HTTP.Status.ServerError
  public static let gatewayTimeout: VNNetworkService.HTTP.Status.ServerError
  public static let httpVersionNotSupported: VNNetworkService.HTTP.Status.ServerError
  public static let variantAlsoNegotiates: VNNetworkService.HTTP.Status.ServerError
  public static let insufficientStorage: VNNetworkService.HTTP.Status.ServerError
  public static let loopDetected: VNNetworkService.HTTP.Status.ServerError
  public static let notExtended: VNNetworkService.HTTP.Status.ServerError
  public static let networkAuthenticationRequired: VNNetworkService.HTTP.Status.ServerError
}
public class VNNetworkService {
  public init(session: Foundation.URLSession = URLSession.shared)
  @objc deinit
}
public struct ResponseError : Swift.Error {
  public typealias DictionaryType = [Swift.AnyHashable : Any]
  public var data: Foundation.Data
  public var stringValue: Swift.String?
  public var dictionaryValue: VNNetworkService.ResponseError.DictionaryType?
  public init(data: Foundation.Data)
  public init(string: Swift.String)
}
extension VNNetworkService : VNNetworkService.VNNetworkServiceProtocol {
  public func executeRequest(request: Foundation.URLRequest, completion: @escaping VNNetworkService.VNNetworkServiceCompletion)
  public func executeRequest<T>(request: T, completion: @escaping (Swift.Result<Foundation.Data?, VNNetworkService.ResponseError>) -> Swift.Void) where T : VNNetworkService.Request
  public func cancelTask(for request: Foundation.URLRequest)
  public func cancelAll()
}
extension OSLog {
  public static let network: os.OSLog
}
public protocol ParameterEncoding {
  func encode(_ urlRequest: Foundation.URLRequest, with parameters: [Swift.String : Any]?) throws -> Foundation.URLRequest
}
public struct URLEncoding : VNNetworkService.ParameterEncoding {
  public init()
  public func encode(_ urlRequest: Foundation.URLRequest, with parameters: [Swift.String : Any]?) throws -> Foundation.URLRequest
}
@dynamicMemberLookup public enum JSON {
  case dictionary(Swift.Dictionary<Swift.String, VNNetworkService.JSON>)
  case array(Swift.Array<VNNetworkService.JSON>)
  case string(Swift.String)
  case number(Foundation.NSNumber)
  case bool(Swift.Bool)
  case null
  public subscript(dynamicMember member: Swift.String) -> VNNetworkService.JSON {
    get
  }
  public subscript(index: Swift.Int) -> VNNetworkService.JSON {
    get
  }
  public subscript(key: Swift.String) -> VNNetworkService.JSON {
    get
  }
  public init(data: Foundation.Data, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) throws
  public init(_ object: Any)
  public var dictionary: Swift.Dictionary<Swift.String, VNNetworkService.JSON>? {
    get
  }
  public var array: Swift.Array<VNNetworkService.JSON>? {
    get
  }
  public var string: Swift.String? {
    get
  }
  public var number: Foundation.NSNumber? {
    get
  }
  public var double: Swift.Double? {
    get
  }
  public var int: Swift.Int? {
    get
  }
  public var bool: Swift.Bool? {
    get
  }
  public var object: Any {
    get
  }
  public func data(options: Foundation.JSONSerialization.WritingOptions = []) -> Foundation.Data
}
extension JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
  case UnableToGetInitialFlags
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (VNNetworkService.Reachability) -> ()
  public typealias NetworkUnreachable = (VNNetworkService.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: VNNetworkService.Reachability.NetworkStatus, b: VNNetworkService.Reachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Connection : Swift.CustomStringConvertible {
    case none, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: VNNetworkService.Reachability.Connection, b: VNNetworkService.Reachability.Connection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: VNNetworkService.Reachability.NetworkReachable?
  public var whenUnreachable: VNNetworkService.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: VNNetworkService.Reachability.Connection {
    get
  }
  public var connection: VNNetworkService.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension JSONDecoder {
  public func decode<T, U>(_ type: T.Type, from data: Foundation.Data, with container: U.Type) throws -> T where T == U.ContainedType, U : VNNetworkService.VNDecodableContainer
}
open class VNHTTPClient {
  public static let `default`: VNNetworkService.VNHTTPClient
  @objc deinit
}
extension VNHTTPClient : VNNetworkService.HTTPServiceProtocol {
  public func executeRequest<T>(request: T, completion: @escaping (Swift.Result<T.ResponseType, T.ErrorType>) -> Swift.Void) where T : VNNetworkService.Request
}
public enum VNNetworkError : Swift.Error, Swift.Equatable {
  case unknownError
  case unknownStatusCode
  case redirection
  case clientError(VNNetworkService.HTTP.Status.ClientError)
  case serverError(VNNetworkService.HTTP.Status.ServerError)
  case noData
  case noInternetConnection
  case timedOut
  case cancelled
  public static func == (a: VNNetworkService.VNNetworkError, b: VNNetworkService.VNNetworkError) -> Swift.Bool
}
public struct VNNetworkServiceSuccess : Swift.Equatable {
  public let data: Foundation.Data
  public let response: VNNetworkService.HTTP.Response
  public init(data: Foundation.Data, response: VNNetworkService.HTTP.Response)
  public static func == (a: VNNetworkService.VNNetworkServiceSuccess, b: VNNetworkService.VNNetworkServiceSuccess) -> Swift.Bool
}
public struct VNNetworkServiceFailure : Swift.Error, Swift.Equatable {
  public static func == (lhs: VNNetworkService.VNNetworkServiceFailure, rhs: VNNetworkService.VNNetworkServiceFailure) -> Swift.Bool
  public let error: VNNetworkService.VNNetworkError
  public let response: VNNetworkService.HTTP.Response?
  public init(error: VNNetworkService.VNNetworkError, response: VNNetworkService.HTTP.Response?)
}
public typealias VNNetworkServiceResult = Swift.Result<VNNetworkService.VNNetworkServiceSuccess, VNNetworkService.VNNetworkServiceFailure>
public typealias VNNetworkServiceCompletion = (VNNetworkService.VNNetworkServiceResult) -> Swift.Void
public protocol VNNetworkServiceProtocol {
  func executeRequest(request: Foundation.URLRequest, completion: @escaping VNNetworkService.VNNetworkServiceCompletion)
}
public protocol ResultProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  init(value: Self.Value)
  init(error: Self.Error)
  var result: Swift.Result<Self.Value, Self.Error> { get }
}
extension Result {
  public var value: Swift.Result<Success, Failure>.Value? {
    get
  }
  public var error: Swift.Result<Success, Failure>.Error? {
    get
  }
  public func map<U>(_ transform: (Swift.Result<Success, Failure>.Value) -> U) -> Swift.Result<U, Swift.Result<Success, Failure>.Error>
  public func flatMap<U>(_ transform: (Swift.Result<Success, Failure>.Value) -> Swift.Result<U, Swift.Result<Success, Failure>.Error>) -> Swift.Result<U, Swift.Result<Success, Failure>.Error>
  public func fanout<U>(_ other: @autoclosure () -> Swift.Result<U, Swift.Result<Success, Failure>.Error>) -> Swift.Result<(Swift.Result<Success, Failure>.Value, U), Swift.Result<Success, Failure>.Error>
  public func mapError<Error2>(_ transform: (Swift.Result<Success, Failure>.Error) -> Error2) -> Swift.Result<Swift.Result<Success, Failure>.Value, Error2> where Error2 : Swift.Error
  public func flatMapError<Error2>(_ transform: (Swift.Result<Success, Failure>.Error) -> Swift.Result<Swift.Result<Success, Failure>.Value, Error2>) -> Swift.Result<Swift.Result<Success, Failure>.Value, Error2> where Error2 : Swift.Error
  public func bimap<U, Error2>(success: (Swift.Result<Success, Failure>.Value) -> U, failure: (Swift.Result<Success, Failure>.Error) -> Error2) -> Swift.Result<U, Error2> where Error2 : Swift.Error
}
extension Result {
  public func recover(_ value: @autoclosure () -> Swift.Result<Success, Failure>.Value) -> Swift.Result<Success, Failure>.Value
  public func recover(with result: @autoclosure () -> Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error>) -> Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error>
}
public protocol ErrorConvertible : Swift.Error {
  static func error(from error: Swift.Error) -> Self
}
extension Result where Failure : VNNetworkService.ErrorConvertible {
  public func tryMap<U>(_ transform: (Swift.Result<Success, Failure>.Value) throws -> U) -> Swift.Result<U, Swift.Result<Success, Failure>.Error>
}
extension Result {
  public static func ?? (left: Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error>, right: @autoclosure () -> Swift.Result<Success, Failure>.Value) -> Swift.Result<Success, Failure>.Value
  public static func ?? (left: Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error>, right: @autoclosure () -> Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error>) -> Swift.Result<Swift.Result<Success, Failure>.Value, Swift.Result<Success, Failure>.Error>
}
@available(*, unavailable, renamed: "ErrorConvertible")
public protocol ErrorProtocolConvertible : VNNetworkService.ErrorConvertible {
}
public struct VNAnyError : Swift.Error, VNNetworkService.VNNetworkServiceFailureInitializable {
  public let error: Swift.Error
  public var httpServiceError: VNNetworkService.VNNetworkError {
    get
  }
  public var failureResponse: VNNetworkService.HTTP.Response?
  public init(_ error: Swift.Error)
  public init(networkServiceFailure: VNNetworkService.VNNetworkServiceFailure)
}
extension VNAnyError : VNNetworkService.ErrorConvertible {
  public static func error(from error: Swift.Error) -> VNNetworkService.VNAnyError
  public static func error(from vnNetworkError: VNNetworkService.VNNetworkError) -> VNNetworkService.VNAnyError
}
extension VNAnyError {
  public static var errorDomain: Swift.String {
    get
  }
  public static var lineKey: Swift.String {
    get
  }
  public static var functionKey: Swift.String {
    get
  }
  public static var fileKey: Swift.String {
    get
  }
  public static func error(_ message: Swift.String? = nil, function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line) -> Foundation.NSError
}
public struct HTTPServiceHelper {
  public static func handleNetworkServiceSuccess<T>(_ serviceSuccess: VNNetworkService.VNNetworkServiceSuccess, for request: T, completion: @escaping VNNetworkService.HTTPServiceCompletion<T.ResponseType, T.ErrorType>) where T : VNNetworkService.Request
  public static func handleResponse<T, U>(_ response: T, completion: @escaping VNNetworkService.HTTPServiceCompletion<T, U>) where U : Swift.Error
  public static func handleNetworkServiceFailure<T, U>(_ serviceFailure: VNNetworkService.VNNetworkServiceFailure, completion: @escaping VNNetworkService.HTTPServiceCompletion<T, U>) where U : VNNetworkService.VNNetworkServiceFailureInitializable
  public static func handleErrorFailure<T, U>(_ error: U, completion: @escaping VNNetworkService.HTTPServiceCompletion<T, U>) where U : Swift.Error
}
@objc public class NetworkOperation : Foundation.Operation {
  @objc override dynamic public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isFinished: Swift.Bool {
    @objc get
  }
  public init(closure: @escaping (@escaping () -> Swift.Void) -> Swift.Void)
  @objc override dynamic public func main()
  @objc override dynamic public init()
  @objc deinit
}
extension URL {
  public func appendingQueryItems(_ queryItems: [Foundation.URLQueryItem]) -> Foundation.URL?
}
public typealias HTTPServiceCompletion<T, E> = (Swift.Result<T, E>) -> Swift.Void where E : Swift.Error
public protocol HTTPServiceProtocol {
  func executeRequest<T>(request: T, completion: @escaping VNNetworkService.HTTPServiceCompletion<T.ResponseType, T.ErrorType>) where T : VNNetworkService.Request
}
public struct VNNetworkServiceHelper {
  public static func networkServiceFailure(for clientError: Swift.Error?) -> VNNetworkService.VNNetworkServiceFailure
  public static func networkServiceResult(for response: VNNetworkService.HTTP.Response) -> VNNetworkService.VNNetworkServiceResult
}
public class Oauth {
  public typealias Credentials = (key: Swift.String, secret: Swift.String)
  public static func calculateSignature(url: Foundation.URL, method: Swift.String, consumerCredentials cc: VNNetworkService.Oauth.Credentials, userCredentials uc: VNNetworkService.Oauth.Credentials?) -> Swift.String
  public static func httpBody(forFormParameters paras: [Swift.String : Swift.String], encoding: Swift.String.Encoding = .utf8) -> Foundation.Data?
  @objc deinit
}
extension CharacterSet {
  public static let rfc3986Unreserved: Foundation.CharacterSet
}
public struct VNRequest<T> : VNNetworkService.Request {
  public typealias TransformBlock = VNNetworkService.RequestTransformBlock<T, VNNetworkService.VNAnyError>
  public var method: VNNetworkService.HTTP.Method
  public var url: Foundation.URL
  public var headers: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]?
  public var body: Foundation.Data?
  public var cachePolicy: Foundation.URLRequest.CachePolicy
  public var timeout: Foundation.TimeInterval
  public init(method: VNNetworkService.HTTP.Method, url: Foundation.URL, headers: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]? = nil, body: Foundation.Data? = nil, cachePolicy: Foundation.URLRequest.CachePolicy = RequestDefaults.defaultCachePolicy, timeout: Foundation.TimeInterval = RequestDefaults.defaultTimeout, dataTransformer: @escaping VNNetworkService.VNRequest<T>.TransformBlock)
  public func transformSuccess(_ serviceSuccess: VNNetworkService.VNNetworkServiceSuccess) -> Swift.Result<T, VNNetworkService.VNAnyError>
  public typealias ResponseType = T
  public typealias ErrorType = VNNetworkService.VNAnyError
}
extension VNRequest where T : Swift.Decodable {
  public init(method: VNNetworkService.HTTP.Method, url: Foundation.URL, headers: [VNNetworkService.HTTP.HeaderKey : VNNetworkService.HTTP.HeaderValue]? = nil, body: Foundation.Data? = nil, cachePolicy: Foundation.URLRequest.CachePolicy = RequestDefaults.defaultCachePolicy, timeout: Foundation.TimeInterval = RequestDefaults.defaultTimeout, decoder: Foundation.JSONDecoder = JSONDecoder())
}
extension VNNetworkService.HTTP.Method : Swift.Equatable {}
extension VNNetworkService.HTTP.Method : Swift.Hashable {}
extension VNNetworkService.HTTP.Method : Swift.RawRepresentable {}
@available(*, unavailable, renamed: "Connection")
extension VNNetworkService.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension VNNetworkService.Reachability.NetworkStatus : Swift.Hashable {}
extension VNNetworkService.Reachability.Connection : Swift.Equatable {}
extension VNNetworkService.Reachability.Connection : Swift.Hashable {}
